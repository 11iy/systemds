#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Print summary stats about the distribution of missing values in a univariate time series.
# ------------------------------------------------------------------------------
# NAME                      TYPE        DEFAULT     MEANING
# ------------------------------------------------------------------------------
# X                         Matrix      ---         Numeric Vector (‘vector’) object containing NAs
# bins                      Integer     4           Split number for bin stats. Number of bins the time series gets divided into. 
#                                                   For each bin information about amount/percentage of missing values is printed. 
#                                                   Default value is 4 - which means stats about the 1st,2nd,3rd,4th quarter of the time series are shown.
# verbose                   Boolean     TRUE        Choose if the function print or Returns. 
#                                                   For print_only = TRUE the function has no return value and just prints out  missing value stats. 
#                                                   If print_only is changed to FALSE, nothing is printed and the function returns a list.
#                                                   Print gives a little bit more information, 
#                                                   since the returned list does not include "Stats for Bins" and "overview NA series"
# ------------------------------------------------------------------------------
# stats                    Matrix      Double       Column vector where each row correspond to following, 
#                                                   1. "Length of time series" - Number of observations in the time-series (including NAs)
#                                                   2. "Number of Missing Values" - Number of missing values in the time series
#                                                   3. "Percentage of Missing Values" - Percentage of missing values in the time series
#                                                   4. "Number of Gaps" - Number of NA gaps (consisting of one or more consecutive NAs) in the time series
#                                                   5. "Average Gap Size" - Average size of consecutive NAs for the NA gaps in the time series
#                                                   6. "Longest NA gap" - Longest series of consecutive missing values (NAs in a row) in the time series
#                                                   7. "Most frequent gap size" - Most frequent occurring series of missing values in the time series
#                                                   8. "Gap size accounting for most NAs" - The series of consecutive missing values that accounts for most missing 
#                                                       values overall in the time series
# ------------------------------------------------------------------------------

m_statsNA = function(Matrix[Double] X, Integer bins = 4, Boolean verbose = TRUE)
  return( Matrix[Double] stats) {
  
  longest_nan_gap = -1
  most_frequent_nan_gap = -1
  most_weighty_nan_gap = -1
  stats = matrix(0, rows=8, cols=1)

  if(ncol(X) != 1) {
     stop("statsNA: expect a matrix with only one column");
  }

  # Count total entries
  length_series = length(X);
  # store length
  stats[1, 1] = length_series

  if (length_series == 0) {
     stop("EMPTY MATRIX")
  }

  if (length_series < bins) {
    print("Warning: data is less than no. of bins, bins value was changed to 4");
    bins = 4;
  } else if (length_series < 1) {
    print("Warning: bin value can not be zero, bin value was changed to 1");
    bins = 1;
  }

  # Count NaNs
  p_position_nans = is.na(X)
  number_nans = sum(p_position_nans);
  # stop if no null value found in data
  if(number_nans == 0)
    stop("No missing value found in the data.")
  
  stats[2, 1] =  number_nans
  
  # Calculate percentage of NaNs
  stats[3, 1]  = number_nans / length_series;
  # Create Vector with numbers of gaps
  p_gaps_vector = matrix(0, length_series, 1);
  p_length_of_gap = 0;
  for (i in 1:length_series) {
    if (as.scalar(p_position_nans[i,1]) == 1) {
      p_length_of_gap += 1;
    } 
    else if (p_length_of_gap != 0){
      p_gaps_vector[p_length_of_gap, 1] = as.scalar(p_gaps_vector[p_length_of_gap, 1]) + 1;
      p_length_of_gap = 0;
    }
  }
   
  # The last element can also be a NaN but the loop will not update our vector map, so this workaround is needed.
  if(p_length_of_gap > 0) 
    p_gaps_vector[p_length_of_gap, 1] = as.scalar(p_gaps_vector[p_length_of_gap, 1]) + 1;
  

  # Count number of gaps
  number_nan_gaps = sum(p_gaps_vector);
  stats[4, 1] = number_nan_gaps
  # Calculate average gap size
  stats[5, 1]  = number_nans / number_nan_gaps

    
  # Find longest gap
  longest_nan_gap = max(seq(1, length_series) * (p_gaps_vector>0))
  stats[6, 1] = longest_nan_gap

  # Find most frequent gap size
  stats[7, 1]  = as.scalar(rowIndexMax(t(p_gaps_vector)));

  # Gap size that has most NaNs
  p_gaps_vector_with_weight = matrix(0, rows=length_series, cols=1);
  for(i in 1:length_series) {
    p_gaps_vector_with_weight[i, 1] = i * as.scalar(p_gaps_vector[i,1]);
  }
  # Find most gap size with most weight
  stats[8, 1]  = as.scalar(rowIndexMax(t(p_gaps_vector_with_weight)));

  # Calculate bins
  #---
  bins_start = matrix(0, bins, 1);
  bins_end = matrix(0, bins, 1);
  bins_nans = matrix(0, bins, 1);
  bins_percentage = matrix(0, bins, 1);
  bin_length = ceiling(length_series / bins)

  # Calculate where a bin starts and ends
  tmp_splitter = 0
  for(i in 1:bins) {
    bins_start[i,1] = tmp_splitter + 1;
    tmp_splitter = tmp_splitter + bin_length;
    bins_end[i,1] = tmp_splitter;
  }

  for(i in 1:bins) {
    start = as.scalar(bins_start[i,1]);
    end = as.scalar(bins_end[i,1]);
    tmp_nans = sum(p_position_nans[start:end, 1]);

    bins_nans[i,1] = tmp_nans;
    bins_percentage[i,1] = tmp_nans / bin_length;
  }
    #---

  # Print results
  #---
  if (verbose) {
    print("-------------------------")
    print("Length of time series:");
    print(as.scalar(stats[1, 1]));
    print("-------------------------");
    print("Number of Missing Values:");
    print(as.scalar(stats[2, 1]));
    print("-------------------------");
    print("Percentage of Missing Values:");
    print("%3.2f %%", as.scalar(stats[3, 1]));
    print("-------------------------");
    print("Number of Gaps:");
    print(as.scalar(stats[4, 1]));
    print("-------------------------");
    print("Average Gap Size:");
    print("%3.2f %%", as.scalar(stats[5, 1]));
    print("-------------------------");
    print("Longest NA gap (series of consecutive NAs)");
    print(as.scalar(stats[6, 1]));
    print("-------------------------");
    print("Most frequent gap size (series of consecutive NA series)");
    print(as.scalar(stats[7, 1]));
    print("-------------------------");
    print("Gap size accounting for most NAs");
    print(as.scalar(stats[8, 1]));
    print("-------------------------");
    if(bins > 0) {
      print("Stats for Bins")
      for (i in 1:bins) {
        l = bin_length
        s = as.scalar(bins_start[i,1]);
        e = as.scalar(bins_end[i,1]);
        n = as.scalar(bins_nans[i,1]);
        p = as.scalar(bins_percentage[i,1]);
        print("  Bin %d (%2.0f values from %2.0f to %2.0f):%5.0f NAs (%3.2f %%)", i,l,s,e,n,p);
      }
      print("-------------------------")
    }
    print("Stats for Bins")
    for (i in 1:bins) {
      v = as.scalar(p_gaps_vector[i,1]);
      if(v > 0) {
        print(" %.0f NA in a row: %d times", v, i);
      }
    }
    print("-------------------------")
  } 
}

