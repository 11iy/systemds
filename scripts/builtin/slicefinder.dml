#-------------------------------------------------------------
#
# Copyright 2019 Graz University of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#-------------------------------------------------------------


m_slicefinder = function(Matrix[Double] X0, Matrix[Double] W, Integer k = 1) return(Matrix[Double] result) {

  f = 2;
  beta = W;
  # number of features combined
  col = ncol(X0);
  row = nrow(X0);
  val_matrix = matrix(0, rows = 2, cols = col - 1);
  vcol = ncol(val_matrix);
  empty_row = matrix(0, rows = 1, cols = col - 1);
  print("col: " + col + " row = " + row);
  #first scan, spot data, make first slices

  for (j in 1:col - 1) {
    vector = order(target = X0[, j], by = 1, decreasing = FALSE);
    val_matrix[2, j] = vector[1, 1];
    val_counter = 1;
    print("Col " + j);
    for (i in 1:row) {
      if (as.scalar(val_matrix[val_counter + 1, j]) != as.scalar(vector[i, 1])) {
        if (nrow(val_matrix) == val_counter + 1)
          val_matrix = rbind(val_matrix, empty_row);
        val_counter = val_counter + 1;
        val_matrix[val_counter + 1, j] = vector[i, 1];
      }
    }

    val_matrix[1, j] = val_counter;
    #here I can add some condition to split the values from each column if val_counter is too big;
    ################################################
    #this code relates to large datasets
    /* if (val_counter > k) {
      position = floor(val_counter / k);
      for (a in 1:k) {
        if (a == k) {
          pos = as.scalar(val_matrix[1, j]) + 1;
          tresh = val_matrix[pos, j];
          val_matrix[a + 1, j] = tresh;
        } else {
          pos = position * a;
          tresh = val_matrix[pos, j];
          val_matrix[a + 1, j] = tresh;
        }
      }
    }
    */
    ##################################################
  }

  # now val_matrix[1:4,]) is a treshhold matrix that define clear slices
  print(toString(val_matrix));

  #start selecting slices
  vrow = nrow(val_matrix);
  vcol = ncol(val_matrix);
  totalrows = (vrow - 1) * vcol;
  print("vrow: " + vrow);
  print("vcol: " + vcol);
  print("totalrows: " + totalrows);

  #######################################
  Y0 = X0[1:nrow(X0), ncol(X0)];
  Y = lmpredict(X = X0[1:nrow(X0), 1:col - 1], w = beta, icpt = 0);
  [error0, diff0] = standart_error(Y, Y0);
  print("Error0: " + error0);
  print("diff0: " + diff0);

  #####################################################

  set_matrix = matrix(0, rows = 1, cols = 2 + (8 * f));
  set_row = matrix(0, rows = 1, cols = 2 + (8 * f));

  cont = 1;

  b0 = 1;
  b1 = col - 1;
  slice_number = 0;
  pointer_col = 1;
  pointer_row = 2;

  set_matrix = first_slices(val_matrix, set_matrix, X0,set_row, beta);

  ress = order(target = set_matrix, by = 1, decreasing = TRUE);
  set_matrix = double_features(val_matrix, set_matrix, X0,Y, set_row, beta);


  ress = order(target = set_matrix, by = 1, decreasing = TRUE);
  set_rows = nrow(set_matrix);
  set_cols = ncol(set_matrix);
  print("Second ress");
  print(toString(ress));
  print(set_rows);

  result = ress;
}

standart_error = function(matrix[double] Y, matrix[double] Y0) return(double error, double diff) {
  diff = var(Y0 - Y);
  error = sqrt(sum((Y0 - Y)^2) / (nrow(Y) - 2));
}

index = function(matrix[double] X, Integer column, double value, Integer mode) return(Integer pos) {
  begin = 1;
  e = nrow(X) + 1;
  while (begin < e - 1) {
    pos = as.integer(floor((begin + e) / 2));
    if (mode == 0) {
      if (as.scalar(X[pos, column]) < value)
        begin = pos;
      else
        e = pos;
    }
    else if (mode == 1) {
      if (as.scalar(X[pos, column]) <= value)
        begin = pos;
      else
        e = pos;
    }
  }
}

first_slices = function(Matrix[Double] val_matrix, Matrix[Double] set_matrix, Matrix[Double] X0, Matrix[Double] set_row, Matrix[Double] beta) return(Matrix[Double] set_matrix) {
  col = ncol(X0);
  row = nrow(X0);
  vrow = nrow(val_matrix);
  vcol = ncol(val_matrix);
  cont = nrow(set_matrix);
  b0 = 1;
  b1 = col - 1;

  for (j in 1:vcol) {
    num_value = as.scalar(val_matrix[1,j]);
    x = order(target = X0, by = j, decreasing = FALSE);
    print("my col: " + j)
    for (i in 2:num_value+1) {
      swich = 1;
      if (nrow(set_matrix) < cont)
        set_matrix = rbind(set_matrix, set_row);

      if (swich == 1) {
        value = as.scalar(val_matrix[i, j]);
        a0 = index(x, j, value, 0);
        a1 = index(x, j, value, 1);
        slice_matrix = x[a0:a1, b0:b1];
        Y0 = x[a0:a1, col];
        Y = lmpredict(X = slice_matrix, w = beta, icpt = 0);
        [error, diff] = standart_error(Y, Y0);
        set_matrix[cont,1:10] = t(as.matrix(list(diff, error, value,
          j, nrow(slice_matrix), ncol(slice_matrix), a0, a1, b0, b1)))
        cont = cont + 1;
        swich = 0;
      }
    }
  }
}


double_features = function(Matrix[Double] val_matrix, Matrix[Double] set_matrix, Matrix[Double] X0,Matrix[Double] Y, Matrix[Double] set_row, Matrix[Double] beta) return(Matrix[Double] set_matrix) {

  vrow = nrow(val_matrix);
  vcol = ncol(val_matrix);
  cont = nrow(set_matrix);
  col = ncol(X0);
  row = nrow(X0);
  totalrows = (vrow - 1) * vcol;
  b0 = 1;
  b1 = col - 1;
  slice_number = 2;

  for (j in 1:vcol) {
    num_value = as.scalar(val_matrix[1,j]);
    x = order(target = X0, by = j, decreasing = FALSE);
    if(j == num_value + 1)
      vrow = vrow -1;
   
    for (i in 2:vrow) {
      if (i > 2 | j > 1)
        slice_number = slice_number + 1;

      for (a in slice_number:totalrows) {
        num_col = as.scalar(set_matrix[a, 4]);
        x_x = order(target = X0, by = num_col, decreasing = FALSE);

        value_A = as.scalar(set_matrix[a, 3]);
        a00 = as.scalar(set_matrix[a,7]);
        a11 = as.scalar(set_matrix[a,8]);
        #print("a0 y a1: " + a00 + " " + a11)
        A = x_x[a00:a11, b0:b1];
        Ya = x_x[a00:a11, col];

        if (nrow(set_matrix) <= cont)
          set_matrix = rbind(set_matrix, set_row);

        value_B = as.scalar(val_matrix[i,j]);
        a0 = index(x, j, value_B, 0);
        a1 = index(x, j, value_B, 1);
        B = x[a0:a1, b0:b1];
        slice_matrix = rbind(A, B);
        Yb = x[a0:a1, col];

        Y0 = rbind(Ya, Yb);
        Y = lmpredict(X = slice_matrix, w = beta, icpt = 0);

        [error, diff] = standart_error(Y, Y0);

        set_matrix[cont, ] = t(as.matrix(list(diff, error, value_A, num_col, nrow(A),
				  ncol(A), a00, a11, b0, b1, value_B, j, nrow(B), ncol(B), a0, a1, b0, b1)));
        cont = cont + 1;
      }
    }
  }
}
